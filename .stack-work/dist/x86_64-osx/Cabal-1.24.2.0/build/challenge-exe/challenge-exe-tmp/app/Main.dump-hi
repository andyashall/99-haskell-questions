
==================== FINAL INTERFACE ====================
2017-09-25 11:00:37.62315 UTC

interface main@main:Main 8002
  interface hash: 04cb03ef53b69b491a2f3c485f8d67b0
  ABI hash: a96ee98336f519e7bc8c72911456150d
  export-list hash: 9013d70b6e42de5b1280c721112b8579
  orphan hash: 85792807837221b839ac0b3338955417
  flag hash: 47c6d773297114f4480e2b123a2437d8
  sig of: Nothing
  used TH splices: False
  where
exports:
  Main.compress
  Main.decodeM
  Main.dropN
  Main.dupE
  Main.flat
  Main.isPal
  Main.leng
  Main.lengM
  Main.listN
  Main.main
  Main.myLast
  Main.myNth
  Main.mySLast
  Main.pack
  Main.repE
  Main.revL
  Main.slice
  Main.split
  Main.ListItem{Main.Multiple Main.Single}
  Main.NestedList{Main.Elem Main.List}
module dependencies:
package dependencies: base-4.9.1.0*
                      challenge-0.1.0.0@challenge-0.1.0.0-KebrR78zYzuLT0BP3AmsMm
                      ghc-prim-0.5.0.0 integer-gmp-1.0.0.1
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Monoid base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:GHC.Generics base-4.9.1.0:GHC.IO.Exception
                         base-4.9.1.0:GHC.TypeLits
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:Data.List 07ae2acca6538aa0800bd0a993ac6ac1
import  -/  base-4.9.1.0:Data.OldList 27987919d8da2f92e3f472ca81f730f8
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  base-4.9.1.0:System.IO c9de64c5f5407c4cf1c52500c4d15200
import  -/  challenge-0.1.0.0@challenge-0.1.0.0-KebrR78zYzuLT0BP3AmsMm:Lib bbe63c82b1a111d7b7dc2509dd3df978
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  ghc-prim-0.5.0.0:GHC.Types 89f8de4f08018c9177c98d979eae0e45
31517914bd95ca7a2386f69de39152f9
  $fShowListItem ::
    GHC.Show.Show a => GHC.Show.Show (Main.ListItem a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dShow :: GHC.Show.Show a).
                  @ (Main.ListItem a)
                  (Main.$fShowListItem_$cshowsPrec @ a $dShow)
                  (Main.$fShowListItem_$cshow @ a $dShow)
                  (Main.$fShowListItem_$cshowList @ a $dShow) -}
507c905cf4323446f5cfa6e2242797c1
  $fShowListItem1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
88f064f4407a1c2eabbfaa8587bc4592
  $fShowListItem2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Multiple "#) -}
bfd78b77f45ea94ae091a2def07d90cb
  $fShowListItem3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Single "#) -}
22f35b2d569d5f298b7c549d0a3683ba
  $fShowListItem4 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11#) -}
31517914bd95ca7a2386f69de39152f9
  $fShowListItem_$cshow ::
    GHC.Show.Show a => Main.ListItem a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><S,1*U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (x :: Main.ListItem a) ->
                 case x of wild {
                   Main.Single b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Main.$fShowListItem3
                        (GHC.Show.showsPrec
                           @ a
                           $dShow
                           Main.$fShowListItem4
                           b1
                           (GHC.Types.[] @ GHC.Types.Char))
                   Main.Multiple b1 b2
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Main.$fShowListItem2
                        (case b1 of ww2 { GHC.Types.I# ww3 ->
                         case GHC.Show.$wshowSignedInt
                                11#
                                ww3
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.showSpace1
                                   (GHC.Show.showsPrec
                                      @ a
                                      $dShow
                                      Main.$fShowListItem4
                                      b2
                                      (GHC.Types.[] @ GHC.Types.Char))) of ww4 { (#,#) ww5 ww6 ->
                         GHC.Types.: @ GHC.Types.Char ww5 ww6 } }) }) -}
31517914bd95ca7a2386f69de39152f9
  $fShowListItem_$cshowList ::
    GHC.Show.Show a => [Main.ListItem a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (eta :: [Main.ListItem a])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Main.ListItem a)
                   (Main.$fShowListItem_$cshowsPrec @ a $dShow Main.$fShowListItem1)
                   eta
                   eta1) -}
31517914bd95ca7a2386f69de39152f9
  $fShowListItem_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> Main.ListItem a -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Main.ListItem a) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Main.$w$cshowsPrec @ a w ww1 w2 }) -}
15cb904cbb89516773bd3f92f4fe8ec4
  $sconcatMap :: (a -> [b]) -> [a] -> [b]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a @ b (f :: a -> [b]) (xs :: [a]) ->
                 GHC.Base.build
                   @ b
                   (\ @ b1 (c :: b -> b1 -> b1)[OneShot] (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ a
                      @ b1
                      (\ (x :: a) (b2 :: b1)[OneShot] ->
                       GHC.Base.foldr @ b @ b1 c b2 (f x))
                      n
                      xs)) -}
d63c6e902678bee5b36d56ff4bfddfe2
  $tc'Elem :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17327168035761514749##
                   2325504556886121138##
                   Main.$trModule
                   Main.$tc'Elem1) -}
3c11f571b1c04145eaa95a536e147b32
  $tc'Elem1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Elem"#) -}
46522d52751dc50649257d119071f56c
  $tc'List :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17414508030287696193##
                   1475919201417240795##
                   Main.$trModule
                   Main.$tc'List1) -}
5cd3b142e25354d03ec7218b9a7bf692
  $tc'List1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'List"#) -}
17804e81547f7c90602f2c896e1ce6c3
  $tc'Multiple :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4657229928005733577##
                   1981937757250795924##
                   Main.$trModule
                   Main.$tc'Multiple1) -}
b78c42c8b5103bb106d3e57546fb067b
  $tc'Multiple1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Multiple"#) -}
27878eafe3fb39da72746fbf7268a518
  $tc'Single :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   757164489821052818##
                   13788531866546215356##
                   Main.$trModule
                   Main.$tc'Single1) -}
339c99460c9f65284efceeab557be636
  $tc'Single1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Single"#) -}
a9b7a30c08d8e410af5f11311768f581
  $tcListItem :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6335977066023095106##
                   987280261331379886##
                   Main.$trModule
                   Main.$tcListItem1) -}
4a2667adae5adcf2923421a38cd83a90
  $tcListItem1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "ListItem"#) -}
2cab99f781d3a103295f1513dfbba504
  $tcNestedList :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9067267851135806687##
                   10246202200427909738##
                   Main.$trModule
                   Main.$tcNestedList1) -}
b00d8499870a8efe51b16603ed6ecd91
  $tcNestedList1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "NestedList"#) -}
d6831ef04cb9301b090dfae6f7bb7ec7
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Main.$trModule2 Main.$trModule1) -}
847d9fc3b8e6f0b424199f36b4999bb2
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Main"#) -}
24ef6042833e75ffd7aa98b83ecca98d
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "main"#) -}
31517914bd95ca7a2386f69de39152f9
  $w$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Prim.Int# -> Main.ListItem a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A,A)><S,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Show.Show a)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: Main.ListItem a) ->
                 case w1 of wild {
                   Main.Single b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ a w Main.$fShowListItem4 b1
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char Main.$fShowListItem3 (g x)
                        GHC.Types.True
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Main.$fShowListItem3
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x))) }
                   Main.Multiple b1 b2
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ a w Main.$fShowListItem4 b2
                      } in
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                        = \ (x :: GHC.Base.String) ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Main.$fShowListItem2
                            (case b1 of ww2 { GHC.Types.I# ww3 ->
                             case GHC.Show.$wshowSignedInt
                                    11#
                                    ww3
                                    (GHC.Types.:
                                       @ GHC.Types.Char
                                       GHC.Show.showSpace1
                                       (g x)) of ww4 { (#,#) ww5 ww6 ->
                             GHC.Types.: @ GHC.Types.Char ww5 ww6 } })
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False -> p
                        GHC.Types.True
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x)) } }) -}
5ee9ed065e7a93a4c97978f89ea79aa5
  $wdropN :: [a] -> GHC.Prim.Int# -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>, Inline: [0] -}
7f74c758e272463a80f183ed15265fb1
  $wsplit :: [a] -> GHC.Types.Int -> (# [a], [a] #)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U(U)>,
     Inline: [0] -}
a7fcd793b8606cac7211ca5df5b1d36e
  $wunsafeDrop :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [0] -}
31517914bd95ca7a2386f69de39152f9
  data ListItem a = Single a | Multiple GHC.Types.Int a
3c2dafe73f215d790e902b1f4228cf87
  data NestedList a = Elem a | List [Main.NestedList a]
ce3612a31084e0e439af13567827c356
  compress :: GHC.Classes.Eq a => [a] -> [a]
  {- Arity: 2, Strictness: <L,1*U(1*C(C(U)),A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dEq :: GHC.Classes.Eq a) (eta :: [a]) ->
                 GHC.Base.build
                   @ a
                   (\ @ b1 (c :: a -> b1 -> b1)[OneShot] (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ [a]
                      @ b1
                      (GHC.Base.mapFB @ a @ b1 @ [a] c (GHC.List.head @ a))
                      n
                      (Data.OldList.groupBy @ a (GHC.Classes.== @ a $dEq) eta))) -}
e7d5dcb4e9a5197da82d843459d24b50
  decodeM :: [Main.ListItem a] -> [a]
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (\ @ a ->
                 Main.$sconcatMap
                   @ (Main.ListItem a)
                   @ a
                   (Main.decodeM_decodeHelper @ a)) -}
c4ce06a6be4189e0a2cb5000eb023f91
  decodeM_decodeHelper :: Main.ListItem a -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Main.ListItem a) ->
                 case ds of wild {
                   Main.Single x -> GHC.Types.: @ a x (GHC.Types.[] @ a)
                   Main.Multiple n x -> GHC.List.replicate @ a n x }) -}
07eea12f1e35da829c68b9fa95cab34f
  dropN :: [a] -> GHC.Types.Int -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S(S),1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: [a]) (w1 :: GHC.Types.Int) ->
                 case w1 of ww { GHC.Types.I# ww1 -> Main.$wdropN @ a w ww1 }) -}
00c4c64579cd0082cfd6caaf27574afa
  dupE :: GHC.Classes.Eq a => [a] -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, True)
                (\ @ a (w :: GHC.Classes.Eq a) (w1 :: [a]) -> Main.dupE1 @ a w1) -}
987087bf057d692e7aa3e9c88a9c85cc
  dupE1 :: [a] -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
c707eccff081f220cadd74e84a910a16
  flat :: Main.NestedList a -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: Main.NestedList a) ->
                 case ds of wild {
                   Main.Elem x -> GHC.Types.: @ a x (GHC.Types.[] @ a)
                   Main.List x -> Main.flat1 @ a x }) -}
f6e57b5016e47b755485205469234f84
  flat1 :: [Main.NestedList a] -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
bd1501cb6b2cf059591bdbbe555a23cf
  isPal :: GHC.Classes.Eq a => [a] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dEq :: GHC.Classes.Eq a) (x :: [a]) ->
                 GHC.Classes.$fEq[]_$c==
                   @ a
                   $dEq
                   x
                   (GHC.List.reverse1 @ a x (GHC.Types.[] @ a))) -}
28263ab8243fa9492c2485a0fd3d7723
  leng :: GHC.Classes.Eq a => [a] -> [(GHC.Types.Int, a)]
  {- Arity: 2, Strictness: <L,1*U(1*C(C(U)),A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dEq :: GHC.Classes.Eq a) (xs :: [a]) ->
                 GHC.Base.build
                   @ (GHC.Types.Int, a)
                   (\ @ b1
                      (c :: (GHC.Types.Int, a) -> b1 -> b1)[OneShot]
                      (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ [a]
                      @ b1
                      (GHC.Base.mapFB @ (GHC.Types.Int, a) @ b1 @ [a] c (Main.leng1 @ a))
                      n
                      (Data.OldList.groupBy @ a (GHC.Classes.== @ a $dEq) xs))) -}
d79d6c3d267e5d63fe46150d9ab8a553
  leng1 :: [a] -> (GHC.Types.Int, a)
  {- Arity: 1, Strictness: <L,U>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (x :: [a]) ->
                 (case GHC.List.$wlenAcc @ a x 0# of ww2 { DEFAULT ->
                  GHC.Types.I# ww2 },
                  GHC.List.head @ a x)) -}
5d8053d2df9e519149744bfbdd6b0b4e
  lengM :: GHC.Classes.Eq a => [a] -> [Main.ListItem a]
  {- Arity: 2, Strictness: <L,1*U(1*C(C(U)),A)><S,1*U>,
     Unfolding: (\ @ a ($dEq :: GHC.Classes.Eq a) (xs :: [a]) ->
                 Main.lengM1
                   @ a
                   (Data.OldList.groupBy @ a (GHC.Classes.== @ a $dEq) xs)) -}
1d78a3cd2a615c52bd76a41d5bb8f943
  lengM1 :: [[a]] -> [Main.ListItem a]
  {- Arity: 1, Strictness: <S,1*U> -}
75bac2411b7289ff21e1edc1afbe66e4
  listN :: [a] -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (x :: [a]) ->
                 case GHC.List.$wlenAcc @ a x 0# of ww2 { DEFAULT ->
                 GHC.Types.I# ww2 }) -}
724968e721dc4c45e8ee017d4ac6e67f
  main :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
d5cd442b39991cafbc3e79cb1f03f5a9
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (eta :: GHC.Prim.State#
                             GHC.Prim.RealWorld)[OneShot] ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   Main.main2
                   GHC.Types.True
                   eta) -}
4c42ddb7a6af923585ce506323bbffb7
  main10 :: [GHC.Integer.Type.Integer]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Integer.Type.Integer
                   Main.main17
                   Main.main11) -}
e69100ebc758ce8b81228581f7a8e2c1
  main11 :: [GHC.Integer.Type.Integer]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Integer.Type.Integer
                   Main.main16
                   Main.main12) -}
ebe61b0ce46bd14419f2d4d4fa740e07
  main12 :: [GHC.Integer.Type.Integer]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Integer.Type.Integer
                   Main.main15
                   Main.main13) -}
8228b0464c9d5c2ec54b6b951483f62f
  main13 :: [GHC.Integer.Type.Integer]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Integer.Type.Integer
                   Main.main14
                   (GHC.Types.[] @ GHC.Integer.Type.Integer)) -}
8033b8dfc45330fd8ab0e3ddbae836dd
  main14 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (9) -}
0cef7b1bbbbeb228ccd7875c6694d569
  main15 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (8) -}
075f3fc8de8f296f89ef920cf3e834dc
  main16 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (7) -}
c3906077f5b752a7d1aeca9ab8a0c87b
  main17 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (6) -}
781e1d6a7de130dcb0b6ca126fad4640
  main18 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (5) -}
6dd2723b35db8310272ce6f4a8da95b8
  main19 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (4) -}
d07e319923c708745b07c070d20ec69d
  main2 :: GHC.Base.String
  {- Unfolding: (case Main.slice
                        @ GHC.Integer.Type.Integer
                        Main.main5
                        Main.main4
                        Main.main3 of wild {
                   GHC.Base.Nothing -> GHC.Show.$fShowMaybe3
                   GHC.Base.Just b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        GHC.Show.$fShowMaybe1
                        (GHC.Show.$fShowInteger_$cshowList
                           b1
                           (GHC.Types.[] @ GHC.Types.Char)) }) -}
88da1d092946a91bb9fa26f361acfe85
  main20 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (3) -}
91d9c95ae3d1a3fdc4ab7c5648282b8e
  main21 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (2) -}
6a2b77707eacfb029f8780f86c63c505
  main22 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (1) -}
19c5e878334a30ecbab161e410ae1c7e
  main23 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1,
     Unfolding: (GHC.TopHandler.runMainIO1
                   @ ()
                   Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R))) -}
dd25b60ff45b656887167b14f0fc94bb
  main3 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 5#) -}
3b63309cd76c47bbff1b3e920bb870ef
  main4 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 2#) -}
454b0581f04c6de207369530ed1b8926
  main5 :: [GHC.Integer.Type.Integer]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Integer.Type.Integer
                   Main.main22
                   Main.main6) -}
7e2cde22f841c28554fbb4aaa0503dcd
  main6 :: [GHC.Integer.Type.Integer]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Integer.Type.Integer
                   Main.main21
                   Main.main7) -}
7e8028017a02b1d5c97e702b559c2b15
  main7 :: [GHC.Integer.Type.Integer]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Integer.Type.Integer
                   Main.main20
                   Main.main8) -}
bff33eaee53996dfc5260ad7cfac77be
  main8 :: [GHC.Integer.Type.Integer]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Integer.Type.Integer
                   Main.main19
                   Main.main9) -}
0f62844aa8cb415c0f053862d8766dbe
  main9 :: [GHC.Integer.Type.Integer]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Integer.Type.Integer
                   Main.main18
                   Main.main10) -}
c9186d4a558f96544d65d38cb8685478
  myLast :: [a] -> a
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (x :: [a]) ->
                 case GHC.List.$wlenAcc @ a x 0# of ww2 { DEFAULT ->
                 GHC.List.$w!! @ a x (GHC.Prim.-# ww2 1#) }) -}
3918f121f5025566d64b09797598002f
  myNth :: [a] -> GHC.Types.Int -> a
  {- Arity: 2, Strictness: <S,1*U><S(S),1*U(U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a (x :: [a]) (y :: GHC.Types.Int) ->
                 case y of wild { GHC.Types.I# x1 ->
                 GHC.List.$w!! @ a x (GHC.Prim.-# x1 1#) }) -}
636e0ada07a0150626a24e6477b6206d
  mySLast :: [a] -> a
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (x :: [a]) ->
                 case GHC.List.$wlenAcc @ a x 0# of ww2 { DEFAULT ->
                 GHC.List.$w!! @ a x (GHC.Prim.-# ww2 2#) }) -}
7f25b8113c068e509ff537b59b14f3e2
  pack :: GHC.Classes.Eq a => [a] -> [[a]]
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A)><S,1*U> -}
0c9586c4510f866d9e99cc28c8344e43
  repE :: [a] -> GHC.Types.Int -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U(U)>,
     Unfolding: (\ @ a (xs :: [a]) (n :: GHC.Types.Int) ->
                 letrec {
                   go :: [a] -> [a] {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [a]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ a
                       : y ys
                       -> case n of wild1 { GHC.Types.I# y1 ->
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.<# 0# y1) of wild2 {
                            GHC.Types.False -> go ys
                            GHC.Types.True
                            -> let {
                                 n1 :: [a] = go ys
                               } in
                               let {
                                 lvl3 :: [a] = GHC.Types.: @ a y n1
                               } in
                               letrec {
                                 $wxs :: GHC.Prim.Int# -> [a]
                                   {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
                                 = \ (ww :: GHC.Prim.Int#) ->
                                   case ww of ds1 {
                                     DEFAULT -> GHC.Types.: @ a y ($wxs (GHC.Prim.-# ds1 1#))
                                     1# -> lvl3 }
                               } in
                               $wxs y1 } } }
                 } in
                 go xs) -}
039fc62eca44d9772acc7a687ab6c573
  revL :: [a] -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True) GHC.List.reverse -}
5a3f9a5f5fa20ae6112c21118920c72b
  slice ::
    [a] -> GHC.Types.Int -> GHC.Types.Int -> GHC.Base.Maybe [a]
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,1*U(U)><L,1*U(U)>,
     Unfolding: (\ @ a
                   (ds :: [a])
                   (ds1 :: GHC.Types.Int)
                   (ds2 :: GHC.Types.Int) ->
                 case ds of wild {
                   [] -> Main.slice1 @ a
                   : ipv ipv1
                   -> case ds1 of wild1 { GHC.Types.I# x ->
                      case ds2 of wild2 { GHC.Types.I# y ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# x y) of wild3 {
                        GHC.Types.False
                        -> case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.># x y) of wild4 {
                             GHC.Types.False
                             -> case GHC.List.$wlenAcc @ a wild 0# of ww2 { DEFAULT ->
                                case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.># x ww2) of wild5 {
                                  GHC.Types.False
                                  -> case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.># y ww2) of wild6 {
                                       GHC.Types.False
                                       -> case GHC.Prim.tagToEnum#
                                                 @ GHC.Types.Bool
                                                 (GHC.Prim.<# x 0#) of wild7 {
                                            GHC.Types.False
                                            -> case GHC.Prim.tagToEnum#
                                                      @ GHC.Types.Bool
                                                      (GHC.Prim.<# y 0#) of wild8 {
                                                 GHC.Types.False
                                                 -> case x of wild9 {
                                                      DEFAULT
                                                      -> GHC.Base.Just
                                                           @ [a]
                                                           (let {
                                                              n :: GHC.Prim.Int#
                                                              = GHC.Prim.-# wild9 1#
                                                            } in
                                                            case GHC.Prim.tagToEnum#
                                                                   @ GHC.Types.Bool
                                                                   (GHC.Prim.<=# n 0#) of wild10 {
                                                              GHC.Types.False
                                                              -> case GHC.Prim.tagToEnum#
                                                                        @ GHC.Types.Bool
                                                                        (GHC.Prim.<#
                                                                           0#
                                                                           y) of wild11 {
                                                                   GHC.Types.False
                                                                   -> Main.$wunsafeDrop
                                                                        @ a
                                                                        n
                                                                        (GHC.Types.[] @ a)
                                                                   GHC.Types.True
                                                                   -> Main.$wunsafeDrop
                                                                        @ a
                                                                        n
                                                                        (GHC.List.$wunsafeTake
                                                                           @ a
                                                                           y
                                                                           wild) }
                                                              GHC.Types.True
                                                              -> case GHC.Prim.tagToEnum#
                                                                        @ GHC.Types.Bool
                                                                        (GHC.Prim.<#
                                                                           0#
                                                                           y) of wild11 {
                                                                   GHC.Types.False
                                                                   -> GHC.Types.[] @ a
                                                                   GHC.Types.True
                                                                   -> GHC.List.$wunsafeTake
                                                                        @ a
                                                                        y
                                                                        wild } })
                                                      0#
                                                      -> GHC.Base.Just
                                                           @ [a]
                                                           (case GHC.Prim.tagToEnum#
                                                                   @ GHC.Types.Bool
                                                                   (GHC.Prim.<# 0# y) of wild10 {
                                                              GHC.Types.False -> GHC.Types.[] @ a
                                                              GHC.Types.True
                                                              -> GHC.List.$wunsafeTake
                                                                   @ a
                                                                   y
                                                                   wild }) }
                                                 GHC.Types.True -> GHC.Base.Nothing @ [a] }
                                            GHC.Types.True -> GHC.Base.Nothing @ [a] }
                                       GHC.Types.True -> GHC.Base.Nothing @ [a] }
                                  GHC.Types.True -> GHC.Base.Nothing @ [a] } }
                             GHC.Types.True -> GHC.Base.Nothing @ [a] }
                        GHC.Types.True -> Main.slice1 @ a } } } }) -}
bccdcd67455f8c5021295240dce9b82c
  slice1 :: GHC.Base.Maybe [a]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (\ @ a -> GHC.Base.Just @ [a] (GHC.Types.[] @ a)) -}
94660e69d3898d9d8d4922724d03c623
  split :: [a] -> GHC.Types.Int -> ([a], [a])
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U(U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: [a]) (w1 :: GHC.Types.Int) ->
                 case Main.$wsplit @ a w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
instance [safe] GHC.Show.Show [Main.ListItem] = Main.$fShowListItem
"SPEC/Main concatMap @ [] _ _" [ALWAYS] forall @ a
                                               @ b
                                               ($dFoldable :: Data.Foldable.Foldable [])
  Data.Foldable.concatMap @ [] @ a @ b $dFoldable
  = Main.$sconcatMap @ a @ b
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

